= Service Maturity

Implementing and maintaining a service is iterative work.
The idea is to release early and release often, without having the urge to have all features available right from the beginning.

This page gives an idea on the iterative steps and a way to assess the service maturity.
Except the "Provisioning" iteration and the stable release, all steps in-between can be in any order, as it fits best.
With "feature complete" it's not meant that the service doesn't receive new functionality or doesn't get maintained anymore, we're talking about the default scope outlined on this page.

Important is that every step is independent of each other. A service that implements `Backup and Restore` doesn't necessarily already implement `Logs`.
That in turn also means we must allow some leeway for each service in respect to the requirements, should a service not allow for a feature or makes it overly complex.
A service is allowed to deviate from a requirement when it makes sense and can be documented and reasoned about accordingly.

To understand the personas referenced in this document, see xref:references/glossary.adoc#_personas[Glossary - Personas].

TODO! We currently maintain the service maturity assessment for each service on our product documentation site under https://products.docs.vshn.ch/products/appuio/managed/services_index.html[VSHN Application Catalog -> Services^].

== Initial Release: Cluster Provisioning

As an *End-User* I can:

* provision a Cloud Kubernetes environment on our supported Cloud Service Providers, fully self-service.
* connect to the Cloud Kubernetes API for using it.
* customize my cluster with a pre-defined set of features and components.
** scale my cluster horizontally and vertically, as my needs change.
** choose the https://products.docs.vshn.ch/products/service_levels.html[service level^] of the instance.
* delete the Cloud Kubernetes environment again.

As a *Technical VSHNeer* I can:

* see and configure the https://products.docs.vshn.ch/products/service_levels.html[service level^] of the instance.
* automatically bill the service to the end-user according to the specified price model.

== Iteration: Cluster Maintenance

As an *End-User* I can:

* schedule maintenance windows for my Cloud Kubernetes environment, during which updates, patches, or other changes can be applied automatically.
* receive notifications in advance of any scheduled maintenance, allowing me to plan accordingly and to minimize any disruption to my applications.

As a *Technical VSHNeer* I can:

* monitor the status of the Cloud Kubernetes environment during the maintenance window, to ensure that the maintenance is operating as expected.

== Iteration: Cluster Version Upgrade

As an *End-User* I can:

* schedule an automated upgrade of my Cloud Kubernetes environment to the next minor version.

As a *Technical VSHNeer* I can:

* trigger an automated upgrade of the Cloud Kubernetes environment to the next minor version.

== Iteration: Cluster Backup and Restore

As an *End-User* I can:

* rely on automated backups of my Cloud Kubernetes environment configuration and cluster state.
* schedule backups cluster state backups to run automatically, at a time and frequency that suits my needs.
* configure data retention policies to ensure that backups are kept for the desired length of time.
* quickly and easily restore my Cloud Kubernetes environment to a previous state, including all cluster configuration.
* test restores in a test environment before performing a full restore, to ensure that the backup is fully restorable.

== Iteration: Cluster-Level Metrics and Alerting

As an *End-User* I can:

* access a metrics dashboard to get an overview of the Cloud Kubernetes environment and health.

As a *Technical VSHNeer* I can:

* have a metrics service that will help me keep track of the health and performance of the Cloud Kubernetes environment.
* enable alerting on pre-defined SLIs to VSHN so that VSHN can resolve incidents with priority.
* see SLO reports so that I can get an overview of how well my Cloud Kubernetes environment performs.
* access operations runbooks so that I can resolve upcoming alerts.
* access a metrics dashboard to get an overview of the Cloud Kubernetes environment and health.

== Iteration: End-User Metrics and Alerting

As an *End-User* I can:

* enable a service to automatically collect and aggregate metrics from my Cloud Kubernetes environment and applications, providing a unified view of all metrics.
* have metrics visualized in real-time, with interactive charts and graphs, providing insights into the behavior and performance of my Cloud Kubernetes environment and the applications.
* configure alarms to alert me when specific conditions are met, such as when an application experiences an error.
* create custom dashboards to view metrics that are most important to me, and to quickly identify areas of concern.

== Iteration: Logs

As an *End-User* I can:

* enable collection of historic logs of my applications running on the cluster.
* access historic logs of my application running on the cluster.
* configure retention time of historic logs.

As a *Technical VSHNeer* I can:

* access the logs of the Kubernetes control plane via a user-friendly interface.
* configure retention time of historic logs.

== Iteration: Service Exposure

As an *End-User* I can:

* expose services to the Internet using the `Ingress` Kubernetes objects.
* expose services using the Kubernetes service type `LoadBalancer` in order to access it from outside the cluster (for example from the Internet).

== Iteration: TLS Certificate Handling

As an *End-User* I can:

* order and consume TLS certificates which are renewed automatically.
* use `Ingress` Kubernetes objects with fully automated certificate handling.

== Iteration: Persistent Storage

As an *End-User* I can:

* request and consume RWX (Read-Write-Many) or RWO (Read-Write-Once) storage types.
* order storage without having to specify a storage class.

== Iteration: Authentication

As an *End-User* and *Technical VSHNeer* I can:

* log in to my cluster through a user-friendly interface

== Iteration: Networking

As a *Technical VSHNeer* I can:

* choose from a pre-defined list of CNI plugins.
* customize the network configuration to meet the specific needs of the user's workloads and applications. For example specifying network segmentation, IP address ranges, and other network-level attributes.
* enforce network security policies, such as firewalls, network segmentation, and network access controls.
